import {
  require_react
} from "./chunk-X6MODOAL.js";
import {
  __commonJS
} from "./chunk-J43GMYXM.js";

// node_modules/react-timeago/lib/formatters/buildFormatter.js
var require_buildFormatter = __commonJS({
  "node_modules/react-timeago/lib/formatters/buildFormatter.js"(exports) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = buildFormatter;
    var React = _interopRequireWildcard(require_react());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var normalizeNumber = function normalizeNumber2(numbers, value) {
      return numbers && numbers.length === 10 ? String(value).split("").map(function(digit) {
        return digit.match(/^[0-9]$/) ? numbers[parseInt(digit)] : digit;
      }).join("") : String(value);
    };
    var normalizeFn = function normalizeFn2(value, distanceMillis, numbers) {
      return function(stringOrFn) {
        return typeof stringOrFn === "function" ? stringOrFn(value, distanceMillis).replace(/%d/g, normalizeNumber(numbers, value)) : stringOrFn.replace(/%d/g, normalizeNumber(numbers, value));
      };
    };
    function buildFormatter(strings) {
      return function formatter(_value, _unit, suffix, epochMilliseconds, _nextFormmater, now) {
        var current = now();
        var value = _value;
        var unit = _unit;
        if (unit === "week" && !strings.week && !strings.weeks) {
          var days = Math.round(Math.abs(epochMilliseconds - current) / (1e3 * 60 * 60 * 24));
          value = days;
          unit = "day";
        }
        var normalize = normalizeFn(value, current - epochMilliseconds, strings.numbers != null ? strings.numbers : void 0);
        var dateString = [];
        if (suffix === "ago" && strings.prefixAgo) {
          dateString.push(normalize(strings.prefixAgo));
        }
        if (suffix === "from now" && strings.prefixFromNow) {
          dateString.push(normalize(strings.prefixFromNow));
        }
        var isPlural = value > 1;
        if (isPlural) {
          var stringFn = strings[unit + "s"] || strings[unit] || "%d " + unit;
          dateString.push(normalize(stringFn));
        } else {
          var _stringFn = strings[unit] || strings[unit + "s"] || "%d " + unit;
          dateString.push(normalize(_stringFn));
        }
        if (suffix === "ago" && strings.suffixAgo) {
          dateString.push(normalize(strings.suffixAgo));
        }
        if (suffix === "from now" && strings.suffixFromNow) {
          dateString.push(normalize(strings.suffixFromNow));
        }
        var wordSeparator = typeof strings.wordSeparator === "string" ? strings.wordSeparator : " ";
        return dateString.join(wordSeparator);
      };
    }
  }
});
export default require_buildFormatter();
//# sourceMappingURL=react-timeago_lib_formatters_buildFormatter.js.map
